### Signature

以太坊用的数字签名算法为ECDSA

#### ECDSA

(之前复习过的直接粘贴过来)

##### 基础

$r$,$s$: 签名
$z$:签名的hash值，有时只需要截取最左边N位
$k$:加密的随机数，用作计算$r$和$s$

$d_A$和$Q_A$:私钥和公钥点，对消息进行签名与验证


##### 签名算法（以Secp256k1为例）

通过$d_A$和$Z$就散签名对$r$和$s$
获取曲线的阶数$n$（Secp256k1的为FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141）
生成一个位于$1$~$(n-1)$的随机数$k$（k不能重复使用，否则攻击者可通过其获取私钥）
计算$(x,y) = k*G$,其中$G$为曲线生成点。
计算$r=x mod n$（如果$r = 0$重算）
$s=k^{-1}(z+r*d_A)modn$（如果$s = 0$重算）

#### 签名与承诺的区别

1.数字签名：用于认证消息和签名者身份，确保消息未被篡改。它是一种单向操作，签名者将消息签名后发送给验证者，验证者使用签名者的公钥来验证。
2.承诺：用于在某些场景中提前对一个值做出承诺，同时保证在揭示之前承诺值是隐藏的，并且承诺者无法更改。承诺通常是双阶段操作，首先是承诺，随后是揭示和验证。